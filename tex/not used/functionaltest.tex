\chapter{O teste funcional no teste sistêmico}
%\addcontentsline{toc}{chapter}{O papel do teste funcional no teste sistemico}

	\section{Definições}
		Conforme \citet{jutman2014high}, diferentes definições existem para o conceito de "teste funcional". Uma abordagem entende como um teste que não depende de nenhuma estrutura DfT: dessa forma, este teste somente atua nas entradas funcionais do sistema, e somente observa as saídas funcionais do sistema.
		Em outra abordagem, um teste funcional é entendido como um teste que foi gerado somente para aproveitar as informações funcionais do sistema alvo (i.e., sem ter conhecimento de sua estrutura). Como consequência, este teste não depende de nenhum modelo de falha estrutural, levando a possíveis limitações na sua capacidade de cobertura de falhas.
		Mesmo assim, muitas vezes ambas as definições podem ser adotadas simultaneamente: por exemplo, um teste pode ser gerado começando pelas informações funcionais sobre o sistema, e o teste é aplicado pela reorganização de entradas e saídas funcionais.

	\section{Casos e motivações para o teste funcional}
		O teste funcional pode ser adotado em diferentes casos de teste funcional e pode ser motivado por diferentes razões. Ao tratar dos testes a nível de placa, o teste funcional é tipicamente considerado a etapa final (tabela \ref{tab:testcategories}), que supostamente é para complementar as etapas anteriores com objetivos especificos (e.g., testar as interfaces), permitindo atingir a cobertura de defeitos desejada. \citet{jutman2014high} cita exemplos adicionais do uso do teste funcional à nível sistêmico:
		\begin{itemize}
			\item Durante o teste de manufatura de um SoC, o teste funcional pode complementar o teste estrutural porque talvez possa cobrir alguns defeitos que não são detectados pelo último, e.g., porque o primeiro trabalha tipicamente em velocidades operacional (enquanto algumas técnicas DfT não), ou porque o teste funcional excita o sistema exatamente nas mesmas condições da fase operacional.
			\item Antes de montar um componente em uma placa, pode ser requisitado por regulações ou por conveniência econômica a execução de um teste para checar quando um dispositivo é livre de faltas (independente do teste executado pelo fabricante do dispositivo). Este teste (às vezes chamado de inspeção de recebimento ou \textit{incoming inspection}) é executado pelo fabricante do sistema e é frequentemente baseado somente na abordagem funcional -- até porque as possíveis funções DfT não são documentadas pelo fornecedor do dispositivo.
			\item Durante o teste em campo de uma placa, pode acontecer de que as funcionalidades DfT dos dispositivos que a compõe não estão mais acessíveis (e.g., porque requerem equipamentos de teste automatizado - ATE), ou porque não estão documentados pelo fornecedor dos dispositivos. Dessa forma, a única solução viável para a companhia OEM é frequentemente baseada em um teste funcional. Se o fabricante do componente não fornecer um teste adequado, uma rotina de teste funcional deve de ser desenvolvida começando pelas funções executadas por cada um dos componentes.
		\end{itemize}
	
	\section{Principios do teste funcional}
	
		Na maioria dos casos, um teste sistêmico funcional requer um programa de teste \textit{TP} apropriado para ser executado pelo(s) processador(es) dentro do sistema; espera-se que este programa de teste produza resultados diferentes quando o sistema estiver afetado por uma falta; resultados teriam de ser observados numa porta de saída apropriada ou corresponder a valores deixados em alguma área de memória especificada \citep{jutman2014high}. Quando o foco do teste forem os módulos periféricos, pode ser que seja necessário usar dados de excitação (\textit{TD}) apropriados em portas de entrada específicas, ou alguns dados de saída terá de ser observado em sinais de saída específicos.
		
		Quando o teste funcional é a solução escolhida, dois pontos principais precisam ser considerados \citep{jutman2014high}:
		\begin{itemize}
			\item Como aplicar o teste funcional, isto é, onde armazenar o programa de teste TP, como acionar o processador para executá-lo, como recuperar e checar os resultados produzidos; uma solução comum consiste primeiramente em armazenar o TP numa memória interna ( ou diretamente no cache do processador), acionando a sua execução por sinal de interrupção, e a partir daí checando os resultados na memória de dados (\textit{Software-Based Self-Test, ou SBST}) \citep{psarakis2010microprocessor};
			\item Como gerar o teste funcional (especificamente, o programa de teste TP).
		\end{itemize}
		Soluções para o primeiro assunto são tipicamente dependentes do sistema alvo e das restrições existentes. Para além disso, quando se lida com testagem em campo, a maioria destas tarefas são normalmente gerenciadas pelo Sistema Operacional.
		
		\section{Geração do teste funcional}
			A geração de programas de teste funcional adequados tem sido o objeto de pesquisa de diversas empreitadas de pesquisa, começando por \citet{thatte1980test}, onde os autores propuseram um método para gerar manualmente um programa de teste para um processador simples, conhecendo somente sua ISA (Instruction Set Arquiteture). Curiosamente, o método apresentou experimentalmente ser capaz de atingir uma boa cobertura de falhas (por volta de 90\%).
			
			Nas ultimas décadas, esta abordagem foi estendida para atingir núcleos de processador de maior (e crescente) complexidade, assim como para componentes específicos de sistemas embarcados, como memórias, componentes periféricos e redes de interconexão.
		\section{A geração de testes funcionais para processadores}
			Um bom panorama dos métodos direcionados para núcleos de processadores é reportado em \citet{psarakis2010microprocessor}. Mais recentemente, pesquisadores focaram em módulos específicos dentro dos núcleos dos processadores modernos, como as BPUs (\textit{Branch Prediction Units}), MMUs (\textit{Memory Management Units}), ROBs (\textit{Reorder Buffers}), e controladores de Cache, mostrando que na maioria dos casos é possível desenvolver programas de teste que garantidamente atingem uma alta cobertura de faltas, sem que seja necessário conhecer a implementação detalhada de tais módulos. O interessante é que, algumas destas faltas que afetam tais módulos não produzem resultados errados, mas forçam o processador a se comportar temporariamente de uma maneira diferente, tipicamente requisitando um tempo maior para completar a execução do progrmaa de teste (faltas de desempenho). A detecção destas falhas podem ser particularmente desafiadoras, já que requerem certos artifícios para observar o comportamento temporal do processador de um modo preciso \citep{hatzimihail2007methodology}.
			
			Esforços recentes se direcionaram para o desenvolvimento de programas de testes funcional para processadores multi-núcleos \citep{kaliorakis2014accelerated} e GPUs \citep{di2013software}.
			
			Os métodos acima correspondem principalmente a algoritmos, possibilitando que um engenheiro habilidoso manualmente escreva um programa de teste direcionado para um módulo especifico ou para um processador inteiro. Todavia, o esforço e tempo para alcançar este resultado podem ser significativos, e representam uma grande desvantagem da abordagem funcional. Esforços anteriores para automatizar este processo, baseados em simulação extensiva e técnicas evolutivas \citep{corno2004automatic}, por exemplo, tiveram sucesso limitado, principalmente devido ao grande esforço computacional que elas requerem. Recentemente, foi mostrado em \citet{riefert2014effective} que técnicas formais podem ser exploradas com sucesso para gerar automaticamente programas de teste funcional para um processador com \textit{pipeline}.
			
		\section{A geração de testes funcionais para memórias}
			Considerando que as memórias correspondem à uma grande - e cada vez maior - parte de um sistema, seu teste podem representar um foco importante de teste. Todavia a solução típica depende da adoção de BIST, existem casos onde a abordagem funcional é também de interesse. Nestes casos a solução tradicional reside no desenvolvimento de um programa de teste que performa nos módulos de memória alvo a mesma sequencia de operações de leitura e escrita determinadas por um dado algoritmo de \textit{March}. A principio, isto garante que a mesma cobertura de defeitos é alcançada, ainda que alguns defeitos possam passar desapercebidos devido ao tempo maior entre dois acessos consecutivos às memórias \citep{van2010memory}. Uma extensão interessante da mesma ideia permite transformar testes de reordenação de memórias cache em programas escritos sob medida: \citet{di2011software} propõe um conjunto de regras que permitem transformar automaticamente qualquer algoritmo \textit{March} em um programa de teste correspondente. Já a referência \citet{riga2012functional} estende a mesma abordagem para as memórias cache L2.
		\section{A geração de teste funcional para periféricos e interconexões}
			Ao focar componentes periféricos de comunicação, a abordagem funcional requer a ação combinada do processador, programando o componente e excitando-o/observando-o de um lado, e de um corpo externo (um ATE, por exemplo), excitando/observando o componente a partir do outro lado do canal de comunicação \citep{apostolakis2009test}. Para soluções em campo, onde o ATE dificilmente possa ser usado, uma conexão \textit{loop-back} é frequentemente adotada. Uma abordagem similar pode ser adotada para periféricos do sistema, como controladores de Interrupção e DMA \citep{grosso2012software}.
			
			Vários métodos tem sido propostos para desenvolver um teste funcional capaz de efetivamente detectar faltas nas estruturas de interconexão dentro de um sistema. Como um exemplo, o trabalho em \citet{dalirsani2014structural} foca em faltas estruturais em um NoC (\textit{Network on a Chip}).
		\section{Tópicos Ativos na área de Teste Funcional}
			Na ultima década, foram desenvolvidos métodos para gerar programas de teste funcional sob restrições especificas (e.g., in termos de energia \citep{zhou2006software}) ou provendo informação de diagnóstico \citep{bernardi2008effective}.
			
			Tanto a academia quanto a indústria estão explorando os custos e benefícios da integração da abordagem funcional com um suporte de hardware limitado, como proposto em \citet{bernardi2010exploiting} e \citet{reimann2014advanced}. Ao focar teste de placas, o reuso de instrumentos embarcados e FPGAs on-board (como citado na sessão \ref{advPCBA}) também estão sendo exploradas; 
			Por fim é importante mencionar que ao direcionar arquiteturas de processador mais comuns, como aquelas com processadores VLIW\footnote{\textit{Very Long Instruction Word}}, é possível adotar uma abordagem hierárquica, na qual o programa de teste global pode ser construído, assim que cada unidade que o compõe for conhecida \citep{sabena2012automatic}. Dessa maneira a maior desvantagem da abordagem funcional, correspondendo ao grande custo de gerar manualmente o teste (como uma consequência da falta de ferramentas automatizadas), pode ser encarada.
			
			Seguindo esta abordagem, esperam-se novas empreitadas no futuro próximo, focados na automatização da geração de programas de teste funcional (para ser adotados em diferentes cenários) explorando certas informações vindas do núcleo ou fabricante do dispositivo, assim como do projetista do sistema.
			
			

